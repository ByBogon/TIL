# Index ?

- Index의 의미: 색인 - 내가 원하는 부분을 쉽고 빠르게 찾아서 전달해주는 역할. 즉, 정보 검색에 있어 성능을 올려줄 수 있는 도구
- Indexing 을 하지 않으면 DB를 Full search 하고 값을 반환하기 때문에 트래픽에 따라 성능이 저하됨. 그래서 보통 자주 조회되는 column에 대한 index를 걸면 하나의 index table 이 따로 생성되어 값을 저장해놓고 검색 할때 해당 index table에 있는 값들로 결과 값을 조회해 온다.
- 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 주는것

## Index 동작원리

### Index 동작 순서

- index table에서 where에 포함된 값 검색 -> 해당 값의 id(pk)를 가지고 옴 -> 가져온 id(pk) 값으로 원본 테이블에서 값을 조회해서 가져옴.

### 인덱스 종류 및 알고리즘

#### **B+-Tree 인덱스 알고리즘**

- 일반적으로는 B+-Tree알고리즘을 사용. B+-Tree 인덱스는 칼럼의 값을 변형하지 않고(값의 앞부분만 잘라서 관리함), 원래의 값을 이용해 인덱싱 하는 알고리즘

#### **Hash 인덱스 알고리즘**

- 칼럼의 값으로 해시 값을 계산하여 인덱싱하는 알고리즘으로 매우 빠른 검색 지원. 하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는등 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다. 주로 메모리 기반의 DB에서 많이 사용한다.

#### 그럼 왜 hash 가 아니라 B+-tree 를 일반적으로 사용하는가?

- 데이터에 접근하는 시간복잡도가 O(1)인 hash table 이 더 효율적인것 같지만, 일반적으로 부등호(<>) 연산을 하다보니, hash table 을 사용하게 되면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 생김. 등호(=) 연산에 특화된 hashtable 은 DB의 자료구조에 적합하지 않음.

#### Clustered Index

> 클러스터는 여러 개를 하나로 묶는다는 의미로 주로 사용되는데, 인덱스에서 클러스터드는 비슷한 것들을 묶어서 저장하는 형태로 구현된다. 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안된 것이다. 여기서 비슷한 값들은 물리적으로 인접한 장소에 저장되어 있는 데이터들을 말한다.
> 클러스터드 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다. 즉 프라이머리 키 값이 비슷한 레코드끼리 묶어서 장하는 것을 클러스터드 인덱스라고 표현한다. 클러스터드 인덱스에서는 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며 프라이머리 키 값이 변경되면 그 레코드의 물리적인 저장 위치 또한 변경되어야 한다. 그렇기 때문에 프라이머리 키를 신중하게 결정하고 클러스터드 인덱스를 사용해야 한다.
> 클러스터드 인덱스는 테이블 당 한 개만 생성할 수 있다. 프라이머리 키에 대해서만 적용되기 때문이다. 이에 반해 Non 클러스터드 인덱스는 테이블 당 여러개를 생성할 수 있다.

#### Composite Index

> 결합 인덱스란 인덱스를 생성할 때 두개 이상의 컬럼을 합쳐서 인덱스를 말하는것.
> 주로 SQL 에서 WHERE 절의 조건 컬럼이 2개 이상의 AND 로 연결되어 함께 사용되는 경우에 많이 사용하게 됨.
> 결합 인덱스는 AND 조건으로 검색되는 경우 성능에 아주 중요한 역할을 함.
> **_두개 이상의 조건이 OR로 조회되는 경우는 결합 인덱스를 만들면 안됨_**
> 결합 인덱스에서는 첫번째 조건에서 최대한 많은 데이터를 걸러서 두번째 검사를 쉽게 만들어 주어야 한다.
>
> **결합 인덱스를 구성하는 컬럼의 순서**
>
> > 인덱스를 이용하여 성능 향상의 효과를 기대할 수 있으려면 먼저 해당 인덱스를 이용하여 처리 범위를 최대한 감소시켜야 한다. 성능을 향상시키기 위해서는 결합 인덱스를 구성하는 컬럼은 반드시 다음의 순서에 맞도록 생성해야한다.
> >
> > 1. WHERE 조건에 사용하는 컬럼
> > 2. 컬럼이 사용한 연산자에 의한 인덱스 컬럼 선정
> > 3. 랜덤 액세스를 고려한 인덱스 컬럼 선정
> > 4. 정렬 제거를 위한 인덱스 컬럼 선정
> > 5. 단일 컬럼의 분포도를 고려한 인덱스 컬럼 선정

> 이러한 결합 인덱스 구성 규칙이 생긴 이유는 **_디스크 I/O를 가장 적게 발생시키기 위해서이다._** 이러한 우선 순위로 인덱스를 생성한다면 우리가 원하는 데이터를 추출할 때 최소의 디스크 I/O를 발생시키게 되어 성능을 보장 받을 수 있게 된다.
>
> 결합 인덱스 구성 컬럼 생성 순서의 이유를 한번 살펴보면,
>
> > 1. WHERE 조건에 사용되는 컬럼
> >    > SQL에서 사용되지 않는 컬럼을 특별한 이유 없이 인덱스에 추가하는 경우는 그다지 많지 않다.
